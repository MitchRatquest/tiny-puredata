From 53e985d881da95de641a477b3744c756c409daf8 Mon Sep 17 00:00:00 2001
From: raul <raul@tinybox.domain>
Date: Sat, 4 Jan 2020 11:11:01 -0600
Subject: [PATCH] Rebase this on v2018.01

---
 arch/arm/cpu/arm926ejs/sunxi/Makefile        |  16 +
 arch/arm/cpu/arm926ejs/sunxi/config.mk       |   6 +
 arch/arm/cpu/arm926ejs/sunxi/fel_utils.S     |  38 ++
 arch/arm/cpu/arm926ejs/sunxi/lowlevel_init.S |  68 ++++
 arch/arm/cpu/arm926ejs/sunxi/start.c         |   1 +
 arch/arm/cpu/arm926ejs/sunxi/timer.c         | 113 ++++++
 arch/arm/cpu/arm926ejs/sunxi/u-boot-spl.lds  |  63 ++++
 arch/arm/dts/suniv-f1c100s-licheepi-nano.dts |  58 +++
 arch/arm/dts/suniv-f1c100s.dtsi              |   6 +
 arch/arm/dts/suniv.dtsi                      | 201 ++++++++++
 arch/arm/include/asm/arch-sunxi/dram_suniv.h |  47 +++
 arch/arm/include/asm/arch-sunxi/spi.h        |  29 ++
 arch/arm/include/asm/arch-sunxi/spi_sun4i.h  |  53 +++
 arch/arm/include/asm/arch-sunxi/spi_sun6i.h  |  56 +++
 arch/arm/mach-sunxi/dram_suniv.c             | 496 ++++++++++++++++++++++++
 configs/licheepi_nano_defconfig              |   9 +
 configs/licheepi_nano_spiflash_defconfig     |  25 ++
 drivers/spi/sun6i_spi.c                      | 539 +++++++++++++++++++++++++++
 include/configs/suniv.h                      |  17 +
 include/dt-bindings/clock/suniv-ccu.h        |  69 ++++
 include/dt-bindings/reset/suniv-ccu.h        |  37 ++
 21 files changed, 1947 insertions(+)
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/Makefile
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/config.mk
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/fel_utils.S
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/lowlevel_init.S
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/start.c
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/timer.c
 create mode 100644 arch/arm/cpu/arm926ejs/sunxi/u-boot-spl.lds
 create mode 100644 arch/arm/dts/suniv-f1c100s-licheepi-nano.dts
 create mode 100644 arch/arm/dts/suniv-f1c100s.dtsi
 create mode 100644 arch/arm/dts/suniv.dtsi
 create mode 100644 arch/arm/include/asm/arch-sunxi/dram_suniv.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/spi.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/spi_sun4i.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/spi_sun6i.h
 create mode 100644 arch/arm/mach-sunxi/dram_suniv.c
 create mode 100644 configs/licheepi_nano_defconfig
 create mode 100644 configs/licheepi_nano_spiflash_defconfig
 create mode 100644 drivers/spi/sun6i_spi.c
 create mode 100644 include/configs/suniv.h
 create mode 100644 include/dt-bindings/clock/suniv-ccu.h
 create mode 100644 include/dt-bindings/reset/suniv-ccu.h

diff --git a/arch/arm/cpu/arm926ejs/sunxi/Makefile b/arch/arm/cpu/arm926ejs/sunxi/Makefile
new file mode 100644
index 0000000000..61b9864f6a
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/Makefile
@@ -0,0 +1,16 @@
+#
+# (C) Copyright 2012 Henrik Nordstrom <henrik@henriknordstrom.net>
+#
+# Based on some other Makefile
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+obj-y	+= timer.o
+obj-y	+= lowlevel_init.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y	+= fel_utils.o
+CFLAGS_fel_utils.o := -marm
+endif
diff --git a/arch/arm/cpu/arm926ejs/sunxi/config.mk b/arch/arm/cpu/arm926ejs/sunxi/config.mk
new file mode 100644
index 0000000000..76ffec9df6
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/config.mk
@@ -0,0 +1,6 @@
+# Build a combined spl + u-boot image
+ifdef CONFIG_SPL
+ifndef CONFIG_SPL_BUILD
+ALL-y += u-boot-sunxi-with-spl.bin
+endif
+endif
diff --git a/arch/arm/cpu/arm926ejs/sunxi/fel_utils.S b/arch/arm/cpu/arm926ejs/sunxi/fel_utils.S
new file mode 100644
index 0000000000..ca91377008
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/fel_utils.S
@@ -0,0 +1,38 @@
+/*
+ * Utility functions for FEL mode.
+ *
+ * Copyright (c) 2015 Google, Inc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <asm/system.h>
+#include <linux/linkage.h>
+
+ENTRY(save_boot_params)
+	ldr	r0, =fel_stash
+	str	sp, [r0, #0]
+	str	lr, [r0, #4]
+	mrs	lr, cpsr		@ Read CPSR
+	str	lr, [r0, #8]
+	mrc	p15, 0, lr, c1, c0, 0	@ Read CP15 SCTLR Register
+	str	lr, [r0, #12]
+	mrc	p15, 0, lr, c1, c0, 0	@ Read CP15 Control Register
+	str	lr, [r0, #16]
+	b	save_boot_params_ret
+ENDPROC(save_boot_params)
+
+ENTRY(return_to_fel)
+	mov	sp, r0
+	mov	lr, r1
+	ldr	r0, =fel_stash
+	ldr	r1, [r0, #16]
+	mcr	p15, 0, r1, c1, c0, 0	@ Write CP15 Control Register
+	ldr	r1, [r0, #12]
+	mcr	p15, 0, r1, c1, c0, 0	@ Write CP15 SCTLR Register
+	ldr	r1, [r0, #8]
+	msr	cpsr, r1		@ Write CPSR
+	bx	lr
+ENDPROC(return_to_fel)
diff --git a/arch/arm/cpu/arm926ejs/sunxi/lowlevel_init.S b/arch/arm/cpu/arm926ejs/sunxi/lowlevel_init.S
new file mode 100644
index 0000000000..2bfd907026
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/lowlevel_init.S
@@ -0,0 +1,68 @@
+/*
+ * A lowlevel_init function that sets up the stack to call a C function to
+ * perform further init.
+ *
+ * Based on lowlevel_init.S in armv7 directory, which is:
+ *   (C) Copyright 2010 Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <linux/linkage.h>
+
+.pushsection .text.s_init, "ax"
+WEAK(s_init)
+	bx	lr
+ENDPROC(s_init)
+.popsection
+
+.pushsection .text.lowlevel_init, "ax"
+WEAK(lowlevel_init)
+	/*
+	 * Setup a temporary stack. Global data is not available yet.
+	 */
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
+	ldr	sp, =CONFIG_SPL_STACK
+#else
+	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR
+#endif
+	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
+#ifdef CONFIG_SPL_DM
+	mov	r9, #0
+#else
+	/*
+	 * Set up global data for boards that still need it. This will be
+	 * removed soon.
+	 */
+#ifdef CONFIG_SPL_BUILD
+	ldr	r9, =gdata
+#else
+	sub	sp, sp, #GD_SIZE
+	bic	sp, sp, #7
+	mov	r9, sp
+#endif
+#endif
+	/*
+	 * Save the old lr(passed in ip) and the current lr to stack
+	 */
+	push	{ip, lr}
+
+	/*
+	 * Call the very early init function. This should do only the
+	 * absolute bare minimum to get started. It should not:
+	 *
+	 * - set up DRAM
+	 * - use global_data
+	 * - clear BSS
+	 * - try to start a console
+	 *
+	 * For boards with SPL this should be empty since SPL can do all of
+	 * this init in the SPL board_init_f() function which is called
+	 * immediately after this.
+	 */
+	bl	s_init
+	pop	{ip, pc}
+ENDPROC(lowlevel_init)
+.popsection
diff --git a/arch/arm/cpu/arm926ejs/sunxi/start.c b/arch/arm/cpu/arm926ejs/sunxi/start.c
new file mode 100644
index 0000000000..6b392fa835
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/start.c
@@ -0,0 +1 @@
+/* Intentionally empty. Only needed to get FEL SPL link line right */
diff --git a/arch/arm/cpu/arm926ejs/sunxi/timer.c b/arch/arm/cpu/arm926ejs/sunxi/timer.c
new file mode 100644
index 0000000000..36263896d8
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/timer.c
@@ -0,0 +1,113 @@
+/*
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/timer.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define TIMER_MODE   (0x0 << 7)	/* continuous mode */
+#define TIMER_DIV    (0x0 << 4)	/* pre scale 1 */
+#define TIMER_SRC    (0x1 << 2)	/* osc24m */
+#define TIMER_RELOAD (0x1 << 1)	/* reload internal value */
+#define TIMER_EN     (0x1 << 0)	/* enable timer */
+
+#define TIMER_CLOCK		(24 * 1000 * 1000)
+#define COUNT_TO_USEC(x)	((x) / 24)
+#define USEC_TO_COUNT(x)	((x) * 24)
+#define TICKS_PER_HZ		(TIMER_CLOCK / CONFIG_SYS_HZ)
+#define TICKS_TO_HZ(x)		((x) / TICKS_PER_HZ)
+
+#define TIMER_LOAD_VAL		0xffffffff
+
+#define TIMER_NUM		0	/* we use timer 0 */
+
+/* read the 32-bit timer */
+static ulong read_timer(void)
+{
+	struct sunxi_timer_reg *timers =
+		(struct sunxi_timer_reg *)SUNXI_TIMER_BASE;
+	struct sunxi_timer *timer = &timers->timer[TIMER_NUM];
+
+	/*
+	 * The hardware timer counts down, therefore we invert to
+	 * produce an incrementing timer.
+	 */
+	return ~readl(&timer->val);
+}
+
+/* init timer register */
+int timer_init(void)
+{
+	struct sunxi_timer_reg *timers =
+		(struct sunxi_timer_reg *)SUNXI_TIMER_BASE;
+	struct sunxi_timer *timer = &timers->timer[TIMER_NUM];
+	writel(TIMER_LOAD_VAL, &timer->inter);
+	writel(TIMER_MODE | TIMER_DIV | TIMER_SRC | TIMER_RELOAD | TIMER_EN,
+	       &timer->ctl);
+
+	return 0;
+}
+
+/* timer without interrupts */
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+ulong get_timer_masked(void)
+{
+	/* current tick value */
+	ulong now = TICKS_TO_HZ(read_timer());
+
+	if (now >= gd->arch.lastinc)	/* normal (non rollover) */
+		gd->arch.tbl += (now - gd->arch.lastinc);
+	else {
+		/* rollover */
+		gd->arch.tbl += (TICKS_TO_HZ(TIMER_LOAD_VAL)
+				- gd->arch.lastinc) + now;
+	}
+	gd->arch.lastinc = now;
+
+	return gd->arch.tbl;
+}
+
+/* delay x useconds */
+void __udelay(unsigned long usec)
+{
+	long tmo = USEC_TO_COUNT(usec);
+	ulong now, last = read_timer();
+
+	while (tmo > 0) {
+		now = read_timer();
+		if (now > last)	/* normal (non rollover) */
+			tmo -= now - last;
+		else		/* rollover */
+			tmo -= TIMER_LOAD_VAL - last + now;
+		last = now;
+	}
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CONFIG_SYS_HZ;
+}
diff --git a/arch/arm/cpu/arm926ejs/sunxi/u-boot-spl.lds b/arch/arm/cpu/arm926ejs/sunxi/u-boot-spl.lds
new file mode 100644
index 0000000000..1b667807db
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/sunxi/u-boot-spl.lds
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2018
+ * Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Based on arch/arm/cpu/armv7/sunxi/u-boot-spl.lds:
+ *
+ * (C) Copyright 2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * Based on omap-common/u-boot-spl.lds:
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *	Aneesh V <aneesh@ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+MEMORY { .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\
+		LENGTH = CONFIG_SPL_MAX_SIZE }
+MEMORY { .sdram : ORIGIN = CONFIG_SPL_BSS_START_ADDR, \
+		LENGTH = CONFIG_SPL_BSS_MAX_SIZE }
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	.text      :
+	{
+		__start = .;
+		*(.vectors)
+		arch/arm/cpu/arm926ejs/start.o	(.text)
+		*(.text*)
+	} > .sram
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(.rodata*)) } >.sram
+
+	. = ALIGN(4);
+	.data : { *(SORT_BY_ALIGNMENT(.data*)) } >.sram
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	} > .sram
+
+	. = ALIGN(4);
+	__image_copy_end = .;
+	_end = .;
+
+	.bss :
+	{
+		. = ALIGN(4);
+		__bss_start = .;
+		*(.bss*)
+		. = ALIGN(4);
+		__bss_end = .;
+	} > .sdram
+}
diff --git a/arch/arm/dts/suniv-f1c100s-licheepi-nano.dts b/arch/arm/dts/suniv-f1c100s-licheepi-nano.dts
new file mode 100644
index 0000000000..9c111e6228
--- /dev/null
+++ b/arch/arm/dts/suniv-f1c100s-licheepi-nano.dts
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR X11)
+/*
+ * Copyright 2018 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+/dts-v1/;
+#include "suniv-f1c100s.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Lichee Pi Nano";
+	compatible = "licheepi,licheepi-nano", "allwinner,suniv-f1c100s",
+		     "allwinner,suniv";
+
+	aliases {
+		serial0 = &uart0;
+		spi0 = &spi0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&otg_sram {
+	status = "okay";
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins_a>;
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins_a>;
+	status = "okay";
+};
+
+&usb_otg {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbphy {
+	usb0_id_det-gpio = <&pio 4 2 GPIO_ACTIVE_HIGH>; /* PE2 */
+	status = "okay";
+};
diff --git a/arch/arm/dts/suniv-f1c100s.dtsi b/arch/arm/dts/suniv-f1c100s.dtsi
new file mode 100644
index 0000000000..f084bc8dd1
--- /dev/null
+++ b/arch/arm/dts/suniv-f1c100s.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR X11)
+/*
+ * Copyright 2018 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+#include "suniv.dtsi"
diff --git a/arch/arm/dts/suniv.dtsi b/arch/arm/dts/suniv.dtsi
new file mode 100644
index 0000000000..10da83b53a
--- /dev/null
+++ b/arch/arm/dts/suniv.dtsi
@@ -0,0 +1,201 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR X11)
+/*
+ * Copyright 2018 Icenowy Zheng <icenowy@aosc.io>
+ */
+
+#include <dt-bindings/clock/suniv-ccu.h>
+#include <dt-bindings/reset/suniv-ccu.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&intc>;
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc24M: clk-24M {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			clock-output-names = "osc24M";
+		};
+
+		osc32k: clk-32k {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+			clock-output-names = "osc32k";
+		};
+
+		fake100M: clk-100M {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+			clock-output-names = "fake-100M";
+		};
+	};
+
+	cpus {
+		#address-cells = <0>;
+		#size-cells = <0>;
+
+		cpu {
+			compatible = "arm,arm926ej-s";
+			device_type = "cpu";
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		sram-controller@1c00000 {
+			compatible = "allwinner,sun4i-a10-sram-controller";
+			reg = <0x01c00000 0x30>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			sram_d: sram@10000 {
+				compatible = "mmio-sram";
+				reg = <0x00010000 0x1000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00010000 0x1000>;
+
+				otg_sram: sram-section@0 {
+					compatible = "allwinner,sun4i-a10-sram-d";
+					reg = <0x0000 0x1000>;
+					status = "disabled";
+				};
+			};
+		};
+
+		spi0: spi@1c05000 {
+			compatible = "allwinner,suniv-spi",
+				     "allwinner,sun8i-h3-spi";
+			reg = <0x01c05000 0x1000>;
+			interrupts = <10>;
+			clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_BUS_SPI0>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI0>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		ccu: clock@1c20000 {
+			compatible = "allwinner,suniv-ccu";
+			reg = <0x01c20000 0x400>;
+			clocks = <&osc24M>, <&osc32k>;
+			clock-names = "hosc", "losc";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		intc: interrupt-controller@1c20400 {
+			compatible = "allwinner,suniv-ic";
+			reg = <0x01c20400 0x400>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		pio: pinctrl@1c20800 {
+			compatible = "allwinner,suniv-pinctrl";
+			reg = <0x01c20800 0x400>;
+			interrupts = <38>, <39>, <40>;
+			clocks = <&ccu CLK_BUS_PIO>, <&osc24M>, <&osc32k>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			#gpio-cells = <3>;
+
+			spi0_pins_a: spi0-pins-pc {
+				pins = "PC0", "PC1", "PC2", "PC3";
+				function = "spi0";
+			};
+
+			uart0_pins_a: uart-pins-pe {
+				pins = "PE0", "PE1";
+				function = "uart0";
+			};
+		};
+
+		timer@1c20c00 {
+			compatible = "allwinner,sun4i-a10-timer";
+			reg = <0x01c20c00 0x90>;
+			interrupts = <13>;
+			clocks = <&osc24M>;
+		};
+
+		wdt: watchdog@1c20ca0 {
+			compatible = "allwinner,sun6i-a31-wdt";
+			reg = <0x01c20ca0 0x20>;
+		};
+
+		uart0: serial@1c25000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c25000 0x400>;
+			interrupts = <1>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART0>;
+			resets = <&ccu RST_BUS_UART0>;
+			status = "disabled";
+		};
+
+		uart1: serial@1c25400 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c25400 0x400>;
+			interrupts = <2>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART1>;
+			resets = <&ccu RST_BUS_UART1>;
+			status = "disabled";
+		};
+
+		uart2: serial@1c25800 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c25800 0x400>;
+			interrupts = <3>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART2>;
+			resets = <&ccu RST_BUS_UART2>;
+			status = "disabled";
+		};
+
+		usb_otg: usb@1c13000 {
+			compatible = "allwinner,suniv-musb";
+			reg = <0x01c13000 0x0400>;
+			clocks = <&ccu CLK_BUS_OTG>;
+			resets = <&ccu RST_BUS_OTG>;
+			interrupts = <26>;
+			interrupt-names = "mc";
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			extcon = <&usbphy 0>;
+			allwinner,sram = <&otg_sram 1>;
+			status = "disabled";
+		};
+
+		usbphy: phy@1c13400 {
+			compatible = "allwinner,suniv-usb-phy";
+			reg = <0x01c13400 0x10>;
+			reg-names = "phy_ctrl";
+			clocks = <&ccu CLK_USB_PHY0>;
+			clock-names = "usb0_phy";
+			resets = <&ccu RST_USB_PHY0>;
+			reset-names = "usb0_reset";
+			#phy-cells = <1>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/include/asm/arch-sunxi/dram_suniv.h b/arch/arm/include/asm/arch-sunxi/dram_suniv.h
new file mode 100644
index 0000000000..088eb5b9eb
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/dram_suniv.h
@@ -0,0 +1,47 @@
+/*
+ * suniv DRAM controller register definition
+ *
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Based on xboot's arch/arm32/mach-f1c100s/sys-dram.c, which is:
+ *
+ * Copyright(c) 2007-2018 Jianjun Jiang <8192542@qq.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define PIO_SDRAM_DRV			(0x2c0)
+#define PIO_SDRAM_PULL			(0x2c4)
+
+#define DRAM_SCONR			(0x00)
+#define DRAM_STMG0R			(0x04)
+#define DRAM_STMG1R			(0x08)
+#define DRAM_SCTLR			(0x0c)
+#define DRAM_SREFR			(0x10)
+#define DRAM_SEXTMR			(0x14)
+#define DRAM_DDLYR			(0x24)
+#define DRAM_DADRR			(0x28)
+#define DRAM_DVALR			(0x2c)
+#define DRAM_DRPTR0			(0x30)
+#define DRAM_DRPTR1			(0x34)
+#define DRAM_DRPTR2			(0x38)
+#define DRAM_DRPTR3			(0x3c)
+#define DRAM_SEFR			(0x40)
+#define DRAM_MAE			(0x44)
+#define DRAM_ASPR			(0x48)
+#define DRAM_SDLY0			(0x4C)
+#define DRAM_SDLY1			(0x50)
+#define DRAM_SDLY2			(0x54)
+#define DRAM_MCR0			(0x100)
+#define DRAM_MCR1			(0x104)
+#define DRAM_MCR2			(0x108)
+#define DRAM_MCR3			(0x10c)
+#define DRAM_MCR4			(0x110)
+#define DRAM_MCR5			(0x114)
+#define DRAM_MCR6			(0x118)
+#define DRAM_MCR7			(0x11c)
+#define DRAM_MCR8			(0x120)
+#define DRAM_MCR9			(0x124)
+#define DRAM_MCR10			(0x128)
+#define DRAM_MCR11			(0x12c)
+#define DRAM_BWCR			(0x140)
diff --git a/arch/arm/include/asm/arch-sunxi/spi.h b/arch/arm/include/asm/arch-sunxi/spi.h
new file mode 100644
index 0000000000..66301b24d5
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/spi.h
@@ -0,0 +1,29 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_SPI_H
+#define _SUNXI_SPI_H
+
+#if defined(CONFIG_MACH_SUN6I) || defined(CONFIG_MACH_SUN8I) || \
+	defined(CONFIG_MACH_SUN9I) || defined(CONFIG_MACH_SUN50I)
+#include <asm/arch/spi_sun6i.h>
+#else
+#include <asm/arch/spi_sun4i.h>
+#endif
+
+#define SUNXI_SPI_BURST_CNT(cnt)	((cnt) & 0xffffff)
+#define SUNXI_SPI_XMIT_CNT(cnt)		((cnt) & 0xffffff)
+
+#define SUNXI_SPI_CLK_CTL_CDR2_MASK	0xff
+#define SUNXI_SPI_CLK_CTL_CDR2(div)	((div) & SUNXI_SPI_CLK_CTL_CDR2_MASK)
+#define SUNXI_SPI_CLK_CTL_CDR1_MASK	0xf
+#define SUNXI_SPI_CLK_CTL_CDR1(div)		\
+	(((div) & SUNXI_SPI_CLK_CTL_CDR1_MASK) << 8)
+#define SUNXI_SPI_CLK_CTL_DRS		BIT(12)
+
+#endif /* _SUNXI_SPI_H */
diff --git a/arch/arm/include/asm/arch-sunxi/spi_sun4i.h b/arch/arm/include/asm/arch-sunxi/spi_sun4i.h
new file mode 100644
index 0000000000..c94519651f
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/spi_sun4i.h
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_SPI_SUN4I_H
+#define _SUNXI_SPI_SUN4I_H
+
+struct sunxi_spi_regs {
+	uint32_t rx_data;	/* 0x00 */
+	uint32_t tx_data;	/* 0x04 */
+	union {
+		uint32_t glb_ctl;
+		uint32_t xfer_ctl;
+		uint32_t fifo_ctl;
+		uint32_t burst_ctl;
+	};			/* 0x08 */
+	uint32_t int_ctl;	/* 0x0c */
+	uint32_t int_sta;	/* 0x10 */
+	uint32_t dma_ctl;	/* 0x14 */
+	uint32_t wait;		/* 0x18 */
+	uint32_t clk_ctl;	/* 0x1c */
+	uint32_t burst_cnt;	/* 0x20 */
+	uint32_t xmit_cnt;	/* 0x24 */
+	uint32_t fifo_sta;	/* 0x28 */
+};
+
+#define SUNXI_SPI_CTL_SRST		0
+
+#define SUNXI_SPI_CTL_ENABLE		BIT(0)
+#define SUNXI_SPI_CTL_MASTER		BIT(1)
+#define SUNXI_SPI_CTL_CPHA		BIT(2)
+#define SUNXI_SPI_CTL_CPOL		BIT(3)
+#define SUNXI_SPI_CTL_CS_ACTIVE_LOW	BIT(4)
+#define SUNXI_SPI_CTL_TF_RST		BIT(8)
+#define SUNXI_SPI_CTL_RF_RST		BIT(9)
+#define SUNXI_SPI_CTL_XCH		BIT(10)
+#define SUNXI_SPI_CTL_CS_MASK		0x3000
+#define SUNXI_SPI_CTL_CS(cs)		(((cs) << 12) & SUNXI_SPI_CTL_CS_MASK)
+#define SUNXI_SPI_CTL_DHB		BIT(15)
+#define SUNXI_SPI_CTL_CS_MANUAL		BIT(16)
+#define SUNXI_SPI_CTL_CS_LEVEL		BIT(17)
+#define SUNXI_SPI_CTL_TP		BIT(18)
+
+#define SUNXI_SPI_FIFO_RF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_RF_CNT_BITS	0
+#define SUNXI_SPI_FIFO_TF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_TF_CNT_BITS	16
+
+#endif /* _SUNXI_SPI_SUN4I_H */
diff --git a/arch/arm/include/asm/arch-sunxi/spi_sun6i.h b/arch/arm/include/asm/arch-sunxi/spi_sun6i.h
new file mode 100644
index 0000000000..d9241848f9
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/spi_sun6i.h
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_SPI_SUN6I_H
+#define _SUNXI_SPI_SUN6I_H
+
+struct sunxi_spi_regs {
+	uint32_t unused0[1];
+	uint32_t glb_ctl;	/* 0x04 */
+	uint32_t xfer_ctl;	/* 0x08 */
+	uint32_t unused1[1];
+	uint32_t int_ctl;	/* 0x10 */
+	uint32_t int_sta;	/* 0x14 */
+	uint32_t fifo_ctl;	/* 0x18 */
+	uint32_t fifo_sta;	/* 0x1c */
+	uint32_t wait;		/* 0x20 */
+	uint32_t clk_ctl;	/* 0x24 */
+	uint32_t unused2[2];
+	uint32_t burst_cnt;	/* 0x30 */
+	uint32_t xmit_cnt;	/* 0x34 */
+	uint32_t burst_ctl;	/* 0x38 */
+	uint32_t unused3[113];
+	uint32_t tx_data;	/* 0x200 */
+	uint32_t unused4[63];
+	uint32_t rx_data;	/* 0x300 */
+};
+
+#define SUNXI_SPI_CTL_ENABLE		BIT(0)
+#define SUNXI_SPI_CTL_MASTER		BIT(1)
+#define SUNXI_SPI_CTL_TP		BIT(7)
+#define SUNXI_SPI_CTL_SRST		BIT(31)
+
+#define SUNXI_SPI_CTL_CPHA		BIT(0)
+#define SUNXI_SPI_CTL_CPOL		BIT(1)
+#define SUNXI_SPI_CTL_CS_ACTIVE_LOW	BIT(2)
+#define SUNXI_SPI_CTL_CS_MASK		0x30
+#define SUNXI_SPI_CTL_CS(cs)		(((cs) << 4) & SUNXI_SPI_CTL_CS_MASK)
+#define SUNXI_SPI_CTL_CS_MANUAL		BIT(6)
+#define SUNXI_SPI_CTL_CS_LEVEL		BIT(7)
+#define SUNXI_SPI_CTL_DHB		BIT(8)
+#define SUNXI_SPI_CTL_XCH		BIT(31)
+
+#define SUNXI_SPI_CTL_RF_RST		BIT(15)
+#define SUNXI_SPI_CTL_TF_RST		BIT(31)
+
+#define SUNXI_SPI_FIFO_RF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_RF_CNT_BITS	0
+#define SUNXI_SPI_FIFO_TF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_TF_CNT_BITS	16
+
+#endif /* _SUNXI_SPI_SUN6I_H */
diff --git a/arch/arm/mach-sunxi/dram_suniv.c b/arch/arm/mach-sunxi/dram_suniv.c
new file mode 100644
index 0000000000..40aebf6eba
--- /dev/null
+++ b/arch/arm/mach-sunxi/dram_suniv.c
@@ -0,0 +1,496 @@
+/*
+ * suniv DRAM initialization
+ *
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Based on xboot's arch/arm32/mach-f1c100s/sys-dram.c, which is:
+ *
+ * Copyright(c) 2007-2018 Jianjun Jiang <8192542@qq.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/gpio.h>
+
+#define SDR_T_CAS			(0x2)
+#define SDR_T_RAS			(0x8)
+#define SDR_T_RCD			(0x3)
+#define SDR_T_RP			(0x3)
+#define SDR_T_WR			(0x3)
+#define SDR_T_RFC			(0xd)
+#define SDR_T_XSR			(0xf9)
+#define SDR_T_RC			(0xb)
+#define SDR_T_INIT			(0x8)
+#define SDR_T_INIT_REF			(0x7)
+#define SDR_T_WTR			(0x2)
+#define SDR_T_RRD			(0x2)
+#define SDR_T_XP			(0x0)
+
+enum dram_type
+{
+	DRAM_TYPE_SDR	= 0,
+	DRAM_TYPE_DDR	= 1,
+	/* Not supported yet. */
+	DRAM_TYPE_MDDR	= 2,
+};
+
+struct dram_para
+{
+	u32 size;		/* dram size (unit: MByte) */
+	u32 clk;		/* dram work clock (unit: MHz) */
+	u32 access_mode;	/* 0: interleave mode 1: sequence mode */
+	u32 cs_num;		/* dram chip count  1: one chip  2: two chip */
+	u32 ddr8_remap;		/* for 8bits data width DDR 0: normal  1: 8bits */
+	enum dram_type sdr_ddr;
+	u32 bwidth;		/* dram bus width */
+	u32 col_width;		/* column address width */
+	u32 row_width;		/* row address width */
+	u32 bank_size;		/* dram bank count */
+	u32 cas;		/* dram cas */
+};
+
+struct dram_para suniv_dram_para = {
+	.size = 32,
+	.clk = 156,
+	.access_mode = 1,
+	.cs_num = 1,
+	.ddr8_remap = 0,
+	.sdr_ddr = DRAM_TYPE_DDR,
+	.bwidth = 16,
+	.col_width = 10,
+	.row_width = 13,
+	.bank_size = 4,
+	.cas = 0x3,
+};
+
+static int dram_initial(void)
+{
+	unsigned int time = 0xffffff;
+
+	setbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR, 0x1);
+	while((readl(SUNXI_DRAMC_BASE + DRAM_SCTLR) & 0x1) && time--)
+	{
+		if(time == 0)
+			return 0;
+	}
+	return 1;
+}
+
+static int dram_delay_scan(void)
+{
+	unsigned int time = 0xffffff;
+
+	setbits_le32(SUNXI_DRAMC_BASE + DRAM_DDLYR, 0x1);
+	while((readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) & 0x1) && time--)
+	{
+		if(time == 0)
+			return 0;
+	}
+	return 1;
+}
+
+static void dram_set_autofresh_cycle(u32 clk)
+{
+	u32 val = 0;
+	u32 row = 0;
+	u32 temp = 0;
+
+	row = readl(SUNXI_DRAMC_BASE + DRAM_SCONR);
+	row &= 0x1e0;
+	row >>= 0x5;
+
+	if(row == 0xc)
+	{
+		if(clk >= 1000000)
+		{
+			temp = clk + (clk >> 3) + (clk >> 4) + (clk >> 5);
+			while(temp >= (10000000 >> 6))
+			{
+				temp -= (10000000 >> 6);
+				val++;
+			}
+		}
+		else
+		{
+			val = (clk * 499) >> 6;
+		}
+	}
+	else if(row == 0xb)
+	{
+		if(clk >= 1000000)
+		{
+			temp = clk + (clk >> 3) + (clk >> 4) + (clk >> 5);
+			while(temp >= (10000000 >> 7))
+			{
+				temp -= (10000000 >> 7);
+				val++;
+			}
+		}
+		else
+		{
+			val = (clk * 499) >> 5;
+		}
+	}
+	writel(val, SUNXI_DRAMC_BASE + DRAM_SREFR);
+}
+
+static int dram_para_setup(struct dram_para * para)
+{
+	u32 val = 0;
+
+	val = (para->ddr8_remap) | (0x1 << 1) |
+	      ((para->bank_size >> 2) << 3) |
+	      ((para->cs_num >> 1) << 4) |
+	      ((para->row_width - 1) << 5) |
+	      ((para->col_width - 1) << 9) |
+	      ((para->sdr_ddr ? (para->bwidth >> 4) : (para->bwidth >> 5)) << 13) |
+	      (para->access_mode << 15) |
+	      (para->sdr_ddr << 16);
+
+	writel(val, SUNXI_DRAMC_BASE + DRAM_SCONR);
+	setbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR, 0x1 << 19);
+	return dram_initial();
+}
+
+static u32 dram_check_delay(u32 bwidth)
+{
+	u32 dsize;
+	int i,j;
+	u32 num = 0;
+	u32 dflag = 0;
+
+	dsize = ((bwidth == 16) ? 4 : 2);
+	for(i = 0; i < dsize; i++)
+	{
+		if(i == 0)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR0);
+		else if(i == 1)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR1);
+		else if(i == 2)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR2);
+		else if(i == 3)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR3);
+
+		for(j = 0; j < 32; j++)
+		{
+			if(dflag & 0x1)
+				num++;
+			dflag >>= 1;
+		}
+	}
+	return num;
+}
+
+static int sdr_readpipe_scan(void)
+{
+	u32 k = 0;
+
+	for(k = 0; k < 32; k++)
+	{
+		writel(k, CONFIG_SYS_SDRAM_BASE + 4 * k);
+	}
+	for(k = 0; k < 32; k++)
+	{
+		if(readl(CONFIG_SYS_SDRAM_BASE + 4 * k) != k)
+			return 0;
+	}
+	return 1;
+}
+
+static u32 sdr_readpipe_select(void)
+{
+	u32 value = 0;
+	u32 i = 0;
+	for(i = 0; i < 8; i++)
+	{
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, i << 6);
+		if(sdr_readpipe_scan())
+		{
+			value = i;
+			return value;
+		}
+	}
+	return value;
+}
+
+static u32 dram_check_type(struct dram_para * para)
+{
+	u32 times = 0;
+	int i;
+
+	for(i = 0; i < 8; i++)
+	{
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, i << 6);
+		dram_delay_scan();
+		if(readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) & 0x30)
+			times++;
+	}
+
+	if(times == 8)
+	{
+		para->sdr_ddr = DRAM_TYPE_SDR;
+		return 0;
+	}
+	else
+	{
+		para->sdr_ddr = DRAM_TYPE_DDR;
+		return 1;
+	}
+}
+
+static u32 dram_scan_readpipe(struct dram_para * para)
+{
+	u32 rp_best = 0, rp_val = 0;
+	u32 readpipe[8];
+	int i;
+
+	if(para->sdr_ddr == DRAM_TYPE_DDR)
+	{
+		for(i = 0; i < 8; i++)
+		{
+			clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+					0x7 << 6, i << 6);
+			dram_delay_scan();
+			readpipe[i] = 0;
+			if((((readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) >> 4) & 0x3) == 0x0) &&
+				(((readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) >> 4) & 0x1) == 0x0))
+			{
+				readpipe[i] = dram_check_delay(para->bwidth);
+			}
+			if(rp_val < readpipe[i])
+			{
+				rp_val = readpipe[i];
+				rp_best = i;
+			}
+		}
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, rp_best << 6);
+		dram_delay_scan();
+	}
+	else
+	{
+		clrbits_le32(SUNXI_DRAMC_BASE + DRAM_SCONR,
+			     (0x1 << 16) | (0x3 << 13));
+		rp_best = sdr_readpipe_select();
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, rp_best << 6);
+	}
+	return 0;
+}
+
+static u32 dram_get_dram_size(struct dram_para * para)
+{
+	u32 colflag = 10, rowflag = 13;
+	u32 val1 = 0;
+	u32 count = 0;
+	u32 addr1, addr2;
+	int i;
+
+	para->col_width = colflag;
+	para->row_width = rowflag;
+	dram_para_setup(para);
+	dram_scan_readpipe(para);
+	for(i = 0; i < 32; i++)
+	{
+		*((u8 *)(CONFIG_SYS_SDRAM_BASE + 0x200 + i)) = 0x11;
+		*((u8 *)(CONFIG_SYS_SDRAM_BASE + 0x600 + i)) = 0x22;
+	}
+	for(i = 0; i < 32; i++)
+	{
+		val1 = *((u8 *)(CONFIG_SYS_SDRAM_BASE + 0x200 + i));
+		if(val1 == 0x22)
+			count++;
+	}
+	if(count == 32)
+	{
+		colflag = 9;
+	}
+	else
+	{
+		colflag = 10;
+	}
+	count = 0;
+	para->col_width = colflag;
+	para->row_width = rowflag;
+	dram_para_setup(para);
+	if(colflag == 10)
+	{
+		addr1 = CONFIG_SYS_SDRAM_BASE + 0x400000;
+		addr2 = CONFIG_SYS_SDRAM_BASE + 0xc00000;
+	}
+	else
+	{
+		addr1 = CONFIG_SYS_SDRAM_BASE + 0x200000;
+		addr2 = CONFIG_SYS_SDRAM_BASE + 0x600000;
+	}
+	for(i = 0; i < 32; i++)
+	{
+		*((u8 *)(addr1 + i)) = 0x33;
+		*((u8 *)(addr2 + i)) = 0x44;
+	}
+	for(i = 0; i < 32; i++)
+	{
+		val1 = *((u8 *)(addr1 + i));
+		if(val1 == 0x44)
+		{
+			count++;
+		}
+	}
+	if(count == 32)
+	{
+		rowflag = 12;
+	}
+	else
+	{
+		rowflag = 13;
+	}
+	para->col_width = colflag;
+	para->row_width = rowflag;
+	if(para->row_width != 13)
+	{
+		para->size = 16;
+	}
+	else if(para->col_width == 10)
+	{
+		para->size = 64;
+	}
+	else
+	{
+		para->size = 32;
+	}
+	dram_set_autofresh_cycle(para->clk);
+	para->access_mode = 0;
+	dram_para_setup(para);
+
+	return 0;
+}
+
+static void simple_dram_check(void)
+{
+	volatile u32 *dram = (u32*) CONFIG_SYS_SDRAM_BASE;
+	int i;
+
+	for(i = 0; i < 0x40; i++)
+	{
+		dram[i] = i;
+	}
+
+	for(i = 0; i < 0x40; i++)
+	{
+		if (dram[i] != i) {
+			printf("DRAM initialization failed: dram[0x%x] != 0x%x.", i, dram[i]);
+			while(1) {}
+		}
+	}
+
+	for(i = 0; i < 0x10000; i += 0x40)
+	{
+		dram[i] = i;
+	}
+
+	for(i = 0; i < 0x10000; i += 0x40)
+	{
+		if (dram[i] != i) {
+			printf("DRAM initialization failed: dram[0x%x] != 0x%x.", i, dram[i]);
+			while(1) {}
+		}
+	}
+}
+
+static void do_dram_init(struct dram_para * para)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	u32 val;
+	u8 m; /* PLL_DDR clock factor */
+
+	sunxi_gpio_set_cfgpin(SUNXI_GPB(3), 0x7);
+	udelay(5000);
+	/* TODO: dig out what's them... some analog register? */
+	if(((para->cas) >> 3) & 0x1)
+	{
+		setbits_le32(SUNXI_PIO_BASE + 0x2c4, (0x1 << 23) | (0x20 << 17));
+	}
+
+	if((para->clk >= 144) && (para->clk <= 180))
+	{
+		writel(0xaaa, SUNXI_PIO_BASE + 0x2c0);
+	}
+	if(para->clk >= 180)
+	{
+		writel(0xfff, SUNXI_PIO_BASE + 0x2c0);
+	}
+
+	if(para->cas & BIT(4))
+	{
+		writel(0xd1303333, &ccm->pll5_pattern_cfg);
+	}
+	else if(para->cas & BIT(5))
+	{
+		writel(0xcce06666, &ccm->pll5_pattern_cfg);
+	}
+	else if(para->cas & BIT(6))
+	{
+		writel(0xc8909999, &ccm->pll5_pattern_cfg);
+	}
+	else if(para->cas & BIT(7))
+	{
+		writel(0xc440cccc, &ccm->pll5_pattern_cfg);
+	}
+
+	if((para->clk) <= 96)
+		m = 2;
+	else
+		m = 1;
+
+	val = CCM_PLL5_CTRL_EN | CCM_PLL5_CTRL_UPD |
+	      CCM_PLL5_CTRL_N((para->clk * 2) / (24 / m)) |
+	      CCM_PLL5_CTRL_K(1) | CCM_PLL5_CTRL_M(m);
+	if(para->cas & GENMASK(7, 4))
+	{
+		val |= CCM_PLL5_CTRL_SIGMA_DELTA_EN;
+	}
+	writel(val, &ccm->pll5_cfg);
+	setbits_le32(&ccm->pll5_cfg, CCM_PLL5_CTRL_UPD);
+	mctl_await_completion(&ccm->pll5_cfg, BIT(28), BIT(28));
+	udelay(5000);
+
+	setbits_le32(&ccm->ahb_gate0, (1 << AHB_GATE_OFFSET_MCTL));
+	clrbits_le32(&ccm->ahb_reset0_cfg, (1 << AHB_RESET_OFFSET_MCTL));
+	udelay(50);
+	setbits_le32(&ccm->ahb_reset0_cfg, (1 << AHB_RESET_OFFSET_MCTL));
+
+	clrsetbits_le32(SUNXI_PIO_BASE + 0x2c4, (1 << 16),
+			((para->sdr_ddr == DRAM_TYPE_DDR) << 16));
+
+	val = (SDR_T_CAS << 0) | (SDR_T_RAS << 3) | (SDR_T_RCD << 7) |
+	      (SDR_T_RP << 10) | (SDR_T_WR << 13) | (SDR_T_RFC << 15) |
+	      (SDR_T_XSR << 19) | (SDR_T_RC << 28);
+	writel(val, SUNXI_DRAMC_BASE + DRAM_STMG0R);
+	val = (SDR_T_INIT << 0) | (SDR_T_INIT_REF << 16) | (SDR_T_WTR << 20) |
+	      (SDR_T_RRD << 22) | (SDR_T_XP << 25);
+	writel(val, SUNXI_DRAMC_BASE + DRAM_STMG1R);
+	dram_para_setup(para);
+	dram_check_type(para);
+
+	clrsetbits_le32(SUNXI_PIO_BASE + 0x2c4, (1 << 16),
+			((para->sdr_ddr == DRAM_TYPE_DDR) << 16));
+
+	dram_set_autofresh_cycle(para->clk);
+	dram_scan_readpipe(para);
+	dram_get_dram_size(para);
+	simple_dram_check();
+}
+
+unsigned long sunxi_dram_init(void)
+{
+	do_dram_init(&suniv_dram_para);
+
+	return suniv_dram_para.size * 1024 * 1024;
+}
diff --git a/configs/licheepi_nano_defconfig b/configs/licheepi_nano_defconfig
new file mode 100644
index 0000000000..6e455baadf
--- /dev/null
+++ b/configs/licheepi_nano_defconfig
@@ -0,0 +1,9 @@
+CONFIG_ARM=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_MACH_SUNIV=y
+CONFIG_DRAM_CLK=156
+CONFIG_DRAM_ZQ=0
+# CONFIG_VIDEO_SUNXI is not set
+CONFIG_DEFAULT_DEVICE_TREE="suniv-f1c100s-licheepi-nano"
+CONFIG_SPL=y
+# CONFIG_SPL_DM_SERIAL is not set
diff --git a/configs/licheepi_nano_spiflash_defconfig b/configs/licheepi_nano_spiflash_defconfig
new file mode 100644
index 0000000000..07b6a27dbe
--- /dev/null
+++ b/configs/licheepi_nano_spiflash_defconfig
@@ -0,0 +1,25 @@
+CONFIG_ARM=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_ENV_SIZE=0x8000
+CONFIG_ENV_OFFSET=0xf8000
+CONFIG_MACH_SUNIV=y
+CONFIG_DRAM_CLK=156
+CONFIG_DRAM_ZQ=0
+# CONFIG_VIDEO_SUNXI is not set
+CONFIG_DEFAULT_DEVICE_TREE="suniv-f1c100s-licheepi-nano"
+CONFIG_SPL=y
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPL_SPI_SUNXI=y
+# CONFIG_SPL_DM_SERIAL is not set
+CONFIG_DM_SPI=y
+CONFIG_SUN6I_SPI=y
diff --git a/drivers/spi/sun6i_spi.c b/drivers/spi/sun6i_spi.c
new file mode 100644
index 0000000000..750c4d8819
--- /dev/null
+++ b/drivers/spi/sun6i_spi.c
@@ -0,0 +1,539 @@
+/*
+ * SPI driver for Allwinner sunxi SoCs
+ *
+ * Copyright (C) 2015-2017 Theobroma Systems Design und Consulting GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <common.h>
+#ifdef CONFIG_DM_GPIO
+#include <asm/gpio.h>
+#endif
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <dm.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <wait_bit.h>
+#include <reset.h>
+#include <spi.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sunxi_spi_platdata {
+	void *base;
+	unsigned int max_hz;
+
+	/* We could do with a single delay counter, but it won't do harm
+	   to have two, as the same is the case for most other driver. */
+	uint deactivate_delay_us;	/* Delay to wait after deactivate */
+	uint activate_delay_us;		/* Delay to wait after activate */
+
+#if defined(CONFIG_DM_GPIO)
+	int cs_gpios_num;
+	struct gpio_desc *cs_gpios;
+#endif
+};
+
+struct sunxi_spi_driverdata {
+	unsigned int  fifo_depth;
+};
+
+struct sunxi_spi_privdata {
+	ulong last_transaction_us;	/* Time of last transaction end */
+	unsigned int hz_requested;      /* last requested bitrate */
+	unsigned int hz_actual;         /* currently set bitrate */
+};
+
+struct sunxi_spi_reg {
+	u8	_rsvd[0x4];
+	u32	GCR;   /* SPI Global Control register */
+	u32	TCR;   /* SPI Transfer Control register */
+	u8	_rsvd1[0x4];
+	u32	IER;   /* SPI Interrupt Control register */
+	u32	ISR;   /* SPI Interrupt Status register */
+	u32	FCR;   /* SPI FIFO Control register */
+	u32	FSR;   /* SPI FIFO Status register */
+	u32	WCR;   /* SPI Wait Clock Counter register */
+	u32	CCR;   /* SPI Clock Rate Control register */
+	u8	_rsvd2[0x8];
+	u32	MBC;   /* SPI Burst Counter register */
+	u32	MTC;   /* SPI Transmit Counter register */
+	u32	BCC;   /* SPI Burst Control register */
+	u8      _rsvd3[0x4c];
+	u32     NDMA_MODE_CTL;
+	u8	_rsvd4[0x174];
+	u32	TXD;   /* SPI TX Data register */
+	u8	_rsvd5[0xfc];
+	u32	RXD;   /* SPI RX Data register */
+};
+
+
+#define GCR_MASTER	 BIT(1)
+#define GCR_EN		 BIT(0)
+
+#define TCR_XCH          BIT(31)
+#define TCR_SDC          BIT(11)
+#define TCR_DHB          BIT(8)
+#define TCR_SSSEL_SHIFT  (4)
+#define TCR_SSSEL_MASK   (0x3 << TCR_SSSEL_SHIFT)
+#define TCR_SSLEVEL      BIT(7)
+#define TCR_SSOWNER      BIT(6)
+#define TCR_CPOL         BIT(1)
+#define TCR_CPHA         BIT(0)
+
+#define FCR_RX_FIFO_RST  BIT(31)
+#define FCR_TX_FIFO_RST  BIT(15)
+
+#define BCC_STC_MASK     (0x00FFFFFF)
+
+#define CCTL_SEL_CDR1    0
+#define CCTL_SEL_CDR2    BIT(12)
+#define CDR1(n)          ((n & 0xf) << 8)
+#define CDR2(n)          (((n/2) - 1) & 0xff)
+
+static int sunxi_spi_cs_activate(struct udevice *dev, unsigned cs)
+{
+	struct udevice *bus = dev->parent;
+	struct sunxi_spi_platdata *plat = dev_get_platdata(bus);
+	struct sunxi_spi_reg *spi = (struct sunxi_spi_reg *)plat->base;
+	struct sunxi_spi_privdata *priv = dev_get_priv(bus);
+	int ret = 0;
+
+	debug("%s (%s): cs %d cs_gpios_num %d cs_gpios %p\n",
+	      dev->name, __func__, cs, plat->cs_gpios_num, plat->cs_gpios);
+
+	/* If it's too soon to do another transaction, wait... */
+	if (plat->deactivate_delay_us && priv->last_transaction_us) {
+		ulong delay_us;
+		delay_us = timer_get_us() - priv->last_transaction_us;
+		if (delay_us < plat->deactivate_delay_us)
+			udelay(plat->deactivate_delay_us - delay_us);
+	}
+
+#if defined(CONFIG_DM_GPIO)
+	/* Use GPIOs as chip selects? */
+	if (plat->cs_gpios) {
+		/* Guard against out-of-bounds accesses */
+		if (!(cs < plat->cs_gpios_num))
+			return -ENOENT;
+
+		if (dm_gpio_is_valid(&plat->cs_gpios[cs])) {
+			ret = dm_gpio_set_value(&plat->cs_gpios[cs], 1);
+			goto done;
+		}
+	}
+#endif
+	/* The hardware can control up to 4 CS, however not all of
+	   them will be going to pads. We don't try to second-guess
+	   the DT or higher-level drivers though and just test against
+	   the hard limit. */
+
+	if (!(cs < 4))
+		return -ENOENT;
+
+	/* Control the positional CS output */
+	clrsetbits_le32(&spi->TCR, TCR_SSSEL_MASK, cs << TCR_SSSEL_SHIFT);
+	clrsetbits_le32(&spi->TCR, TCR_SSLEVEL, TCR_SSOWNER);
+
+done:
+	/* We'll delay, even it this is an error return... */
+	if (plat->activate_delay_us)
+		udelay(plat->activate_delay_us);
+
+	return ret;
+}
+
+static void sunxi_spi_cs_deactivate(struct udevice *dev, unsigned cs)
+{
+	struct udevice *bus = dev->parent;
+	struct sunxi_spi_platdata *plat = dev_get_platdata(bus);
+	struct sunxi_spi_reg *spi = (struct sunxi_spi_reg *)plat->base;
+	struct sunxi_spi_privdata *priv = dev_get_priv(bus);
+
+#if defined(CONFIG_DM_GPIO)
+	/* Use GPIOs as chip selects? */
+	if (plat->cs_gpios) {
+		if (dm_gpio_is_valid(&plat->cs_gpios[cs])) {
+			dm_gpio_set_value(&plat->cs_gpios[cs], 0);
+			return;
+		}
+	}
+#endif
+
+	/* We have only the hardware chip select, so use those */
+	setbits_le32(&spi->TCR, TCR_SSLEVEL | TCR_SSOWNER);
+
+	/* Remember time of this transaction for the next delay */
+	if (plat->deactivate_delay_us)
+		priv->last_transaction_us = timer_get_us();
+}
+
+static inline uint8_t *spi_fill_writefifo(struct sunxi_spi_reg *spi,
+					  uint8_t *dout, int cnt)
+{
+	debug("%s: dout = %p, cnt = %d\n", __func__, dout, cnt);
+
+	if (dout) {
+		int i;
+
+		for (i = 0; i < cnt; i++)
+			writeb(dout[i], &spi->TXD);
+
+		dout += cnt;
+	}
+
+	return dout;
+}
+
+static inline uint8_t *spi_drain_readfifo(struct sunxi_spi_reg *spi,
+					  uint8_t *din, int cnt)
+{
+	debug("%s: din = %p, cnt = %d\n", __func__, din, cnt);
+
+	if (din) {
+		int i;
+
+		for (i = 0; i < cnt; i++)
+			din[i] = readb(&spi->RXD);
+
+		din += cnt;
+	}
+
+	return din;
+}
+
+static int sunxi_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			  const void *out, void *in, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct sunxi_spi_platdata *plat = dev_get_platdata(bus);
+	struct sunxi_spi_privdata *priv = dev_get_priv(bus);
+	struct sunxi_spi_reg *spi = (struct sunxi_spi_reg *)plat->base;
+	struct sunxi_spi_driverdata *data =
+		(struct sunxi_spi_driverdata *)dev_get_driver_data(dev->parent);
+	struct dm_spi_slave_platdata *slave = dev_get_parent_platdata(dev);
+	uint8_t *dout = (uint8_t *)out;
+	uint8_t *din = (uint8_t *)in;
+	int fifo_depth = data->fifo_depth;
+	unsigned int n_bytes = DIV_ROUND_UP(bitlen, 8);
+	int ret = 0;
+	/*
+	 * We assume that 1ms (for any delays within the module to
+	 * start the transfer) + 2x the time to transfer a full FIFO
+	 * (for the data- and bitrate-dependent part) is a reasonable
+	 * timeout to detect the module being stuck.
+	 */
+	ulong timeout_ms =
+		(DIV_ROUND_UP(fifo_depth * 16000, priv->hz_actual)) + 1;
+
+	debug("%s (%s): regs %p bitlen %d din %p flags %lx fifo_depth %d\n",
+	      dev->name, __func__, spi, bitlen, din, flags, fifo_depth);
+
+	if (flags & SPI_XFER_BEGIN) {
+		ret = sunxi_spi_cs_activate(dev, slave->cs);
+		if (ret < 0) {
+			printf("%s: failed to activate chip-select %d\n",
+			       dev->name, slave->cs);
+			return ret;
+		}
+	}
+
+	/* Reset FIFO */
+	writel(FCR_RX_FIFO_RST | FCR_TX_FIFO_RST, &spi->FCR);
+	/* Wait until the FIFO reset autoclears */
+	ret = wait_for_bit(dev->name, &spi->FCR,
+			   FCR_RX_FIFO_RST | FCR_TX_FIFO_RST,
+			   false, 10, true);
+	if (ret < 0) {
+		printf("%s: failed to reset FIFO within 10ms\n", bus->name);
+		return ret;
+	}
+
+	/* Set the discard burst bits depending on whether we are receiving */
+	clrbits_le32(&spi->TCR, TCR_DHB);
+	if (!din)
+		setbits_le32(&spi->TCR, TCR_DHB);
+
+	/* Transfer in blocks of FIFO_DEPTH */
+	while (n_bytes > 0) {
+		int cnt = (n_bytes < fifo_depth) ? n_bytes : fifo_depth;
+		int txcnt = dout ? cnt : 0;
+
+		/* We need to set up the transfer counters in every
+		   iteration, as the hardware block counts those down
+		   to 0 and leaves the 0 in the register (i.e. there's
+		   no shadow register within the controller that these
+		   values are copied into). */
+
+		/* master burst counter:     total length (tx + rx + dummy) */
+		writel(cnt, &spi->MBC);
+		/* master transmit counter:  tx */
+		writel(txcnt, &spi->MTC);
+		/* burst control counter:    single-mode tx */
+		clrsetbits_le32(&spi->BCC, BCC_STC_MASK, txcnt & BCC_STC_MASK);
+
+		dout = spi_fill_writefifo(spi, dout, txcnt);
+
+		/* Start transfer ... */
+		setbits_le32(&spi->TCR, TCR_XCH);
+		/* ... and wait until it finshes. */
+		ret = wait_for_bit(dev->name, &spi->TCR, TCR_XCH,
+				   false, timeout_ms, true);
+		if (ret < 0) {
+			printf("%s: stuck in XCH for %ld ms\n",
+			       bus->name, timeout_ms);
+			goto fail;
+		}
+
+		din = spi_drain_readfifo(spi, din, cnt);
+
+		n_bytes -= cnt;
+	}
+
+ fail:
+	if (flags & SPI_XFER_END)
+		sunxi_spi_cs_deactivate(dev, slave->cs);
+
+	return 0;
+};
+
+static int sunxi_spi_ofdata_to_platdata(struct udevice *dev)
+{
+	struct sunxi_spi_platdata *plat = dev_get_platdata(dev);
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	fdt_addr_t addr;
+	fdt_size_t size;
+
+	debug("%s: %p\n", __func__, dev);
+
+	addr = fdtdec_get_addr_size_auto_noparent(blob, node, "reg", 0,
+						  &size, false);
+	if (addr == FDT_ADDR_T_NONE) {
+		debug("%s: failed to find base address\n", dev->name);
+		return -ENODEV;
+	}
+	plat->base = (void *)addr;
+	plat->max_hz = fdtdec_get_int(blob, node, "spi-max-frequency", 0);
+	plat->activate_delay_us = fdtdec_get_int(blob, node,
+						 "spi-activate_delay", 0);
+	plat->deactivate_delay_us = fdtdec_get_int(blob, node,
+						   "spi-deactivate-delay", 0);
+
+#if defined(CONFIG_DM_GPIO)
+	plat->cs_gpios_num = gpio_get_list_count(dev, "cs-gpios");
+	if (plat->cs_gpios_num > 0) {
+		int i;
+
+		plat->cs_gpios = calloc(plat->cs_gpios_num,
+					sizeof(struct gpio_desc));
+		if (!plat->cs_gpios)
+			return -ENOMEM;
+
+		for (i = 0; i < plat->cs_gpios_num; ++i)
+			gpio_request_by_name(dev, "cs-gpios", i,
+					     &plat->cs_gpios[i], 0);
+	}
+#endif
+	return 0;
+}
+
+static int sunxi_spi_probe(struct udevice *dev)
+{
+	unsigned int pin_func = SUNXI_GPC_SPI0;
+	int ret;
+
+	if (IS_ENABLED(CONFIG_MACH_SUN50I))
+		pin_func = SUN50I_GPC_SPI0;
+
+	if (IS_ENABLED(CONFIG_MACH_SUNIV))
+		pin_func = SUNIV_GPC_SPI0;
+
+	ret = sunxi_gpio_setup_dt_pins(gd->fdt_blob, dev_of_offset(dev),
+				       NULL, pin_func);
+
+	if (ret < 0) {
+		printf("SPI: pinctrl node not found.\n");
+	} else if (!ret) {
+		printf("SPI: pinctrl node not valid.\n");
+	}
+
+	return (ret <= 0) ? -EINVAL : 0;
+}
+
+static int sunxi_spi_claim_bus(struct udevice *dev)
+{
+	struct sunxi_spi_platdata *plat = dev_get_platdata(dev->parent);
+	struct spi_slave *spi_slave = dev_get_parent_priv(dev);
+	struct sunxi_spi_reg *spi = (struct sunxi_spi_reg *)plat->base;
+
+	debug("%s: %p %p\n", __func__, dev, dev->parent);
+
+	/* Enable in master-mode */
+	setbits_le32(&spi->GCR, GCR_MASTER | GCR_EN);
+	/* All CS control is manual and set them to inactive */
+	clrbits_le32(&spi->TCR, TCR_SSSEL_MASK);
+	setbits_le32(&spi->TCR, TCR_SSOWNER);
+	/* Apply polarity and phase from the mode bits */
+	if (spi_slave->mode & SPI_CPOL)
+		setbits_le32(&spi->TCR, TCR_CPOL);
+	if (spi_slave->mode & SPI_CPHA)
+		setbits_le32(&spi->TCR, TCR_CPHA);
+
+#if defined(DM_GPIO)
+	/* Set all cs-gpios to inactive */
+	for (i = 0; i < plat->cs_gpios_num; ++i)
+		if (dm_gpio_is_valid(&plat->cs_gpios[i]))
+			dm_gpio_set_value(&plat->cs_gpios[i], 0);
+#endif
+
+
+	return 0;
+}
+
+static int sunxi_spi_release_bus(struct udevice *dev)
+{
+	struct sunxi_spi_platdata *plat = dev_get_platdata(dev->parent);
+	struct sunxi_spi_reg *spi = (struct sunxi_spi_reg *)plat->base;
+
+	clrbits_le32(&spi->GCR, GCR_EN);
+
+	return 0;
+}
+
+static int sunxi_spi_set_speed(struct udevice *bus, unsigned int hz)
+{
+	struct sunxi_ccm_reg *ccm = (struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_spi_platdata *plat = dev_get_platdata(bus);
+	struct sunxi_spi_reg *spi = (struct sunxi_spi_reg *)plat->base;
+	struct sunxi_spi_privdata *priv = dev_get_priv(bus);
+	unsigned sclk_shift, hz_ahb, hz_sclk, target_freq;
+
+	debug("%s: %p, %d\n", __func__, bus, hz);
+
+	if (plat->max_hz && (hz > plat->max_hz)) {
+		debug("%s: selected speed (%d) exceeds maximum of %d\n",
+		      bus->name, hz, plat->max_hz);
+		hz = plat->max_hz;
+	}
+
+	/* If the last request was for the same speed, we're done */
+	if (priv->hz_requested == hz)
+		return 0;
+
+	/* The CCU section in the manual recommends to have the module
+	   reset deasserted before the module clock gate is opened. */
+	setbits_le32(&ccm->ahb_reset0_cfg, 1 << AHB_RESET_OFFSET_SPI0);
+
+
+	/* Enable and set the module clock.
+	 *
+	 * At least for the A31, there's a requirements to provide at
+	 * least 2x the sample clock, so we should never go below that
+	 * ratio between the AHB clock and the (ampling) SCLK. On the
+	 * low end of the clock, we use the provide two step-downs for
+	 * clocks on the low end (below 375kHz).
+	 *
+	 * However, testing shows that for high-speed modes (on the
+	 * A64), we may not divide SCLK from the AHB clock.
+	 */
+#ifndef CONFIG_MACH_SUNIV
+	if (hz < 100000)
+		sclk_shift = 8;
+	else if (hz < 50000000)
+		sclk_shift = 2;
+	else
+		sclk_shift = 0;
+
+	setbits_le32(&ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_SPI0);
+
+	/* Program the SPI clock control */
+	writel(CCTL_SEL_CDR1 | CDR1(sclk_shift), &spi->CCR);
+
+	target_freq = hz * (1 << sclk_shift);
+
+	if (target_freq < 24000000) {
+		writel(BIT(31) | max(24000000 / target_freq - 1, 0xf),
+		       &ccm->spi0_clk_cfg);
+		hz_ahb = 24000000 / ((readl(&ccm->spi0_clk_cfg) & 0xf) + 1);
+	} else {
+		writel(BIT(31) | (0x01 << 24) | max(600000000 / target_freq - 1, 0xf),
+		       &ccm->spi0_clk_cfg);
+		hz_ahb = 600000000 / ((readl(&ccm->spi0_clk_cfg) & 0xf) + 1);
+	}
+#else
+	hz_ahb = target_freq = 200000000; /* AHB clock on suniv */
+	sclk_shift = 0;
+	while(target_freq > hz && sclk_shift < 0xf) {
+		target_freq >>= 1;
+		sclk_shift += 1;
+	};
+
+	setbits_le32(&ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_SPI0);
+
+	writel(CCTL_SEL_CDR1 | CDR1(sclk_shift), &spi->CCR);
+#endif
+
+	hz_sclk = hz_ahb >> sclk_shift;
+	priv->hz_actual = hz_sclk;
+	debug("%s: hz_ahb %d  hz_sclk %d\n", bus->name, hz_ahb, hz_sclk);
+
+	/* If this is a high-speed mode (which we define---based upon
+	   empirical testing---to be above 50 MHz), we need to move the
+	   sampling point during data read. */
+	if (hz_sclk > 50000000)
+		setbits_le32(&spi->TCR, TCR_SDC);
+	else
+		clrbits_le32(&spi->TCR, TCR_SDC);
+
+	return 0;
+};
+
+static int sunxi_spi_set_mode(struct udevice *bus, unsigned int mode)
+{
+	return 0;
+};
+
+static const struct dm_spi_ops sunxi_spi_ops = {
+	.claim_bus	= sunxi_spi_claim_bus,
+	.release_bus	= sunxi_spi_release_bus,
+	.xfer		= sunxi_spi_xfer,
+	.set_speed	= sunxi_spi_set_speed,
+	.set_mode	= sunxi_spi_set_mode,
+	/*
+	 * cs_info is not needed, since we require all chip selects to be
+	 * in the device tree explicitly
+	 */
+};
+
+static struct sunxi_spi_driverdata  sun6i_a31_data = {
+	.fifo_depth = 128,
+};
+
+static struct sunxi_spi_driverdata  sun50i_a64_data = {
+	.fifo_depth = 64,
+};
+
+static const struct udevice_id sunxi_spi_ids[] = {
+	{ .compatible = "allwinner,sun6i-a31-spi",
+	  .data = (uintptr_t)&sun6i_a31_data },
+	{ .compatible = "allwinner,sun8i-h3-spi",
+	  .data = (uintptr_t)&sun50i_a64_data },
+	{ }
+};
+
+U_BOOT_DRIVER(sunxi_spi) = {
+	.name = "sunxi_spi",
+	.id = UCLASS_SPI,
+	.of_match = sunxi_spi_ids,
+	.ofdata_to_platdata = sunxi_spi_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct sunxi_spi_platdata),
+	.priv_auto_alloc_size = sizeof(struct sunxi_spi_privdata),
+	.probe = sunxi_spi_probe,
+	.ops = &sunxi_spi_ops,
+};
diff --git a/include/configs/suniv.h b/include/configs/suniv.h
new file mode 100644
index 0000000000..e6aca3ec4b
--- /dev/null
+++ b/include/configs/suniv.h
@@ -0,0 +1,17 @@
+/*
+ * Configuration settings for new Allwinner F-series (suniv) CPU
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_SUNXI_USB_PHYS 1
+
+/*
+ * Include common sunxi configuration where most the settings are
+ */
+#include <configs/sunxi-common.h>
+
+#endif /* __CONFIG_H */
diff --git a/include/dt-bindings/clock/suniv-ccu.h b/include/dt-bindings/clock/suniv-ccu.h
new file mode 100644
index 0000000000..9c22d70b2c
--- /dev/null
+++ b/include/dt-bindings/clock/suniv-ccu.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2018 Icenowy Zheng <icenowy@aosc.xyz>
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUNIV_H_
+#define _DT_BINDINGS_CLK_SUNIV_H_
+
+#define CLK_CPU			11
+
+#define CLK_BUS_MMC0		14
+#define CLK_BUS_MMC1		15
+#define CLK_BUS_DRAM		16
+#define CLK_BUS_SPI0		17
+#define CLK_BUS_SPI1		18
+#define CLK_BUS_OTG		19
+#define CLK_BUS_VE		20
+#define CLK_BUS_LCD		21
+#define CLK_BUS_DEINTERLACE	22
+#define CLK_BUS_CSI		23
+#define CLK_BUS_TVD		24
+#define CLK_BUS_TVE		25
+#define CLK_BUS_DE_BE		26
+#define CLK_BUS_DE_FE		27
+#define CLK_BUS_CODEC		28
+#define CLK_BUS_SPDIF		29
+#define CLK_BUS_IR		30
+#define CLK_BUS_RSB		31
+#define CLK_BUS_I2S0		32
+#define CLK_BUS_I2C0		33
+#define CLK_BUS_I2C1		34
+#define CLK_BUS_I2C2		35
+#define CLK_BUS_PIO		36
+#define CLK_BUS_UART0		37
+#define CLK_BUS_UART1		38
+#define CLK_BUS_UART2		39
+
+#define CLK_MMC0		40
+#define CLK_MMC0_SAMPLE		41
+#define CLK_MMC0_OUTPUT		42
+#define CLK_MMC1		43
+#define CLK_MMC1_SAMPLE		44
+#define CLK_MMC1_OUTPUT		45
+#define CLK_I2S			46
+#define CLK_SPDIF		47
+
+#define CLK_USB_PHY0		48
+
+#define CLK_DRAM_VE		49
+#define CLK_DRAM_CSI		50
+#define CLK_DRAM_DEINTERLACE	51
+#define CLK_DRAM_TVD		52
+#define CLK_DRAM_DE_FE		53
+#define CLK_DRAM_DE_BE		54
+
+#define CLK_DE_BE		55
+#define CLK_DE_FE		56
+#define CLK_TCON		57
+#define CLK_DEINTERLACE		58
+#define CLK_TVE2_CLK		59
+#define CLK_TVE1_CLK		60
+#define CLK_TVD			61
+#define CLK_CSI			62
+#define CLK_VE			63
+#define CLK_CODEC		64
+#define CLK_AVS			65
+
+#endif
diff --git a/include/dt-bindings/reset/suniv-ccu.h b/include/dt-bindings/reset/suniv-ccu.h
new file mode 100644
index 0000000000..993f6b5381
--- /dev/null
+++ b/include/dt-bindings/reset/suniv-ccu.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.xyz>
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ */
+
+#ifndef _DT_BINDINGS_RST_SUNIV_H_
+#define _DT_BINDINGS_RST_SUNIV_H_
+
+#define RST_USB_PHY0		0
+#define RST_BUS_MMC0		1
+#define RST_BUS_MMC1		2
+#define RST_BUS_DRAM		3
+#define RST_BUS_SPI0		4
+#define RST_BUS_SPI1		5
+#define RST_BUS_OTG		6
+#define RST_BUS_VE		7
+#define RST_BUS_LCD		8
+#define RST_BUS_DEINTERLACE		9
+#define RST_BUS_CSI		10
+#define RST_BUS_TVD		11
+#define RST_BUS_TVE		12
+#define RST_BUS_DE_BE		13
+#define RST_BUS_DE_FE		14
+#define RST_BUS_CODEC		15
+#define RST_BUS_SPDIF		16
+#define RST_BUS_IR		17
+#define RST_BUS_RSB		18
+#define RST_BUS_I2S0		19
+#define RST_BUS_I2C0		20
+#define RST_BUS_I2C1		21
+#define RST_BUS_I2C2		22
+#define RST_BUS_UART0		23
+#define RST_BUS_UART1		24
+#define RST_BUS_UART2		25
+
+#endif /* _DT_BINDINGS_RST_SUNIV_H_ */
-- 
2.11.0

